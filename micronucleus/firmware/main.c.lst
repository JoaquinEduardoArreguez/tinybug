GAS LISTING /tmp/ccLOy0FK.s 			page 1


   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/joaquin/github/tinybug/micronucleus/firmware/",100,0,2,.Ltext0
   8               		.stabs	"main.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  18               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  19               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  20               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  21               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  23               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"short _Fract:t(0,15)=r(0,1);1;0;",128,0,0,0
  27               		.stabs	"_Fract:t(0,16)=r(0,1);2;0;",128,0,0,0
  28               		.stabs	"long _Fract:t(0,17)=r(0,1);4;0;",128,0,0,0
  29               		.stabs	"long long _Fract:t(0,18)=r(0,1);8;0;",128,0,0,0
  30               		.stabs	"unsigned short _Fract:t(0,19)=r(0,1);1;0;",128,0,0,0
  31               		.stabs	"unsigned _Fract:t(0,20)=r(0,1);2;0;",128,0,0,0
  32               		.stabs	"unsigned long _Fract:t(0,21)=r(0,1);4;0;",128,0,0,0
  33               		.stabs	"unsigned long long _Fract:t(0,22)=r(0,1);8;0;",128,0,0,0
  34               		.stabs	"_Sat short _Fract:t(0,23)=r(0,1);1;0;",128,0,0,0
  35               		.stabs	"_Sat _Fract:t(0,24)=r(0,1);2;0;",128,0,0,0
  36               		.stabs	"_Sat long _Fract:t(0,25)=r(0,1);4;0;",128,0,0,0
  37               		.stabs	"_Sat long long _Fract:t(0,26)=r(0,1);8;0;",128,0,0,0
  38               		.stabs	"_Sat unsigned short _Fract:t(0,27)=r(0,1);1;0;",128,0,0,0
  39               		.stabs	"_Sat unsigned _Fract:t(0,28)=r(0,1);2;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned long _Fract:t(0,29)=r(0,1);4;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned long long _Fract:t(0,30)=r(0,1);8;0;",128,0,0,0
  42               		.stabs	"short _Accum:t(0,31)=r(0,1);2;0;",128,0,0,0
  43               		.stabs	"_Accum:t(0,32)=r(0,1);4;0;",128,0,0,0
  44               		.stabs	"long _Accum:t(0,33)=r(0,1);8;0;",128,0,0,0
  45               		.stabs	"long long _Accum:t(0,34)=r(0,1);8;0;",128,0,0,0
  46               		.stabs	"unsigned short _Accum:t(0,35)=r(0,1);2;0;",128,0,0,0
  47               		.stabs	"unsigned _Accum:t(0,36)=r(0,1);4;0;",128,0,0,0
  48               		.stabs	"unsigned long _Accum:t(0,37)=r(0,1);8;0;",128,0,0,0
  49               		.stabs	"unsigned long long _Accum:t(0,38)=r(0,1);8;0;",128,0,0,0
  50               		.stabs	"_Sat short _Accum:t(0,39)=r(0,1);2;0;",128,0,0,0
  51               		.stabs	"_Sat _Accum:t(0,40)=r(0,1);4;0;",128,0,0,0
  52               		.stabs	"_Sat long _Accum:t(0,41)=r(0,1);8;0;",128,0,0,0
  53               		.stabs	"_Sat long long _Accum:t(0,42)=r(0,1);8;0;",128,0,0,0
  54               		.stabs	"_Sat unsigned short _Accum:t(0,43)=r(0,1);2;0;",128,0,0,0
  55               		.stabs	"_Sat unsigned _Accum:t(0,44)=r(0,1);4;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned long _Accum:t(0,45)=r(0,1);8;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned long long _Accum:t(0,46)=r(0,1);8;0;",128,0,0,0
GAS LISTING /tmp/ccLOy0FK.s 			page 2


  58               		.stabs	"void:t(0,47)=(0,47)",128,0,0,0
  59               		.stabs	"/usr/lib/avr/include/avr/io.h",130,0,0,0
  60               		.stabs	"/usr/lib/avr/include/avr/sfr_defs.h",130,0,0,0
  61               		.stabs	"/usr/lib/avr/include/inttypes.h",130,0,0,0
  62               		.stabs	"/usr/lib/gcc/avr/4.9.2/include/stdint.h",130,0,0,0
  63               		.stabs	"/usr/lib/avr/include/stdint.h",130,0,0,0
  64               		.stabs	"int8_t:t(5,1)=(0,10)",128,0,121,0
  65               		.stabs	"uint8_t:t(5,2)=(0,11)",128,0,122,0
  66               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,123,0
  67               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,124,0
  68               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,125,0
  69               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,126,0
  70               		.stabs	"int64_t:t(5,7)=(0,6)",128,0,128,0
  71               		.stabs	"uint64_t:t(5,8)=(0,7)",128,0,129,0
  72               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,142,0
  73               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,147,0
  74               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,159,0
  75               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,164,0
  76               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,169,0
  77               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,174,0
  78               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,179,0
  79               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,184,0
  80               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,192,0
  81               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,199,0
  82               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,213,0
  83               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,218,0
  84               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,223,0
  85               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,228,0
  86               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,233,0
  87               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,238,0
  88               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,246,0
  89               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,253,0
  90               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,273,0
  91               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,278,0
  92               		.stabn	162,0,0,0
  93               		.stabn	162,0,0,0
  94               		.stabs	"int_farptr_t:t(3,1)=(5,5)",128,0,77,0
  95               		.stabs	"uint_farptr_t:t(3,2)=(5,6)",128,0,81,0
  96               		.stabn	162,0,0,0
  97               		.stabn	162,0,0,0
  98               		.stabs	"/usr/lib/avr/include/avr/fuse.h",130,0,0,0
  99               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
 100               		.stabn	162,0,0,0
 101               		.stabn	162,0,0,0
 102               		.stabs	"/usr/lib/avr/include/avr/pgmspace.h",130,0,0,0
 103               		.stabs	"/usr/lib/gcc/avr/4.9.2/include/stddef.h",130,0,0,0
 104               		.stabs	"size_t:t(8,1)=(0,4)",128,0,212,0
 105               		.stabn	162,0,0,0
 106               		.stabn	162,0,0,0
 107               		.stabs	"/usr/lib/avr/include/avr/boot.h",130,0,0,0
 108               		.stabs	"/usr/lib/avr/include/avr/eeprom.h",130,0,0,0
 109               		.stabs	"/usr/lib/gcc/avr/4.9.2/include/stddef.h",130,0,0,0
 110               		.stabs	"ptrdiff_t:t(11,1)=(0,1)",128,0,147,0
 111               		.stabs	"wchar_t:t(11,2)=(0,1)",128,0,324,0
 112               		.stabn	162,0,0,0
 113               		.stabn	162,0,0,0
 114               		.stabn	162,0,0,0
GAS LISTING /tmp/ccLOy0FK.s 			page 3


 115               		.stabs	"usbdrv/usbdrv.c",130,0,0,0
 116               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
 117               		.stabs	"usbTxStatus:T(13,1)=s12len:(13,2)=B(0,11),0,8;buffer:(13,3)=ar(13,4)=r(13,4);0;0177777;;0;
 118               		.stabs	"usbTxStatus_t:t(13,5)=(13,1)",128,0,660,0
 119               		.stabs	"usbWord:T(13,6)=u2word:(0,4),0,16;bytes:(13,7)=ar(13,4);0;1;(0,11),0,16;;",128,0,0,0
 120               		.stabs	"usbWord_t:t(13,8)=(13,6)",128,0,672,0
 121               		.stabs	"usbRequest:T(13,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(13,8),16,16;wInd
 122               		.stabs	"usbRequest_t:t(13,10)=(13,9)",128,0,680,0
 123               		.stabn	162,0,0,0
 124               		.stabn	162,0,0,0
 125               		.stabs	"uint16_union_t:t(0,48)=(0,49)=u2w:(5,4),0,16;b:(0,50)=ar(13,4);0;1;(5,2),0,16;;",128,0,68,
 126               		.stabs	" :T(0,51)=ecmd_local_nop:0,cmd_device_info:0,cmd_transfer_page:1,cmd_erase_application:2,c
 127               		.section	.text.writeWordToPageBuffer,"ax",@progbits
 128               		.stabs	"writeWordToPageBuffer:f(0,47)",36,0,137,writeWordToPageBuffer
 129               		.stabs	"data:P(5,4)",64,0,137,24
 130               		.type	writeWordToPageBuffer, @function
 131               	writeWordToPageBuffer:
 132               		.stabd	46,0,0
   1:main.c        **** /* 
   2:main.c        ****  * Project: Micronucleus -  v2.3
   3:main.c        ****  *
   4:main.c        ****  * Micronucleus V2.3             (c) 2016 Tim Bo"scke - cpldcpu@gmail.com
   5:main.c        ****  *                               (c) 2014 Shay Green
   6:main.c        ****  * Original Micronucleus         (c) 2012 Jenna Fox
   7:main.c        ****  *
   8:main.c        ****  * Based on USBaspLoader-tiny85  (c) 2012 Louis Beaudoin
   9:main.c        ****  * Based on USBaspLoader         (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
  10:main.c        ****  *
  11:main.c        ****  * License: GNU GPL v2 (see License.txt)
  12:main.c        ****  */
  13:main.c        ****  
  14:main.c        **** #define MICRONUCLEUS_VERSION_MAJOR 2
  15:main.c        **** #define MICRONUCLEUS_VERSION_MINOR 3
  16:main.c        **** 
  17:main.c        **** #include <avr/io.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** #include <avr/wdt.h>
  20:main.c        **** #include <avr/boot.h>
  21:main.c        **** #include <util/delay.h>
  22:main.c        **** 
  23:main.c        **** #include "bootloaderconfig.h"
  24:main.c        **** #include "usbdrv/usbdrv.c"
  25:main.c        **** 
  26:main.c        **** // verify the bootloader address aligns with page size
  27:main.c        **** #if (defined __AVR_ATtiny841__)||(defined __AVR_ATtiny441__)  
  28:main.c        ****   #if BOOTLOADER_ADDRESS % ( SPM_PAGESIZE * 4 ) != 0
  29:main.c        ****     #error "BOOTLOADER_ADDRESS in makefile must be a multiple of chip's pagesize"
  30:main.c        ****   #endif
  31:main.c        **** #else
  32:main.c        ****   #if BOOTLOADER_ADDRESS % SPM_PAGESIZE != 0
  33:main.c        ****     #error "BOOTLOADER_ADDRESS in makefile must be a multiple of chip's pagesize"
  34:main.c        ****   #endif  
  35:main.c        **** #endif
  36:main.c        **** 
  37:main.c        **** #if SPM_PAGESIZE>256
  38:main.c        ****   #error "Micronucleus only supports pagesizes up to 256 bytes"
  39:main.c        **** #endif
GAS LISTING /tmp/ccLOy0FK.s 			page 4


  40:main.c        **** 
  41:main.c        **** #if ((AUTO_EXIT_MS>0) && (AUTO_EXIT_MS<1000))
  42:main.c        ****   #error "Do not set AUTO_EXIT_MS to below 1s to allow Micronucleus to function properly"
  43:main.c        **** #endif
  44:main.c        **** 
  45:main.c        **** // Device configuration reply
  46:main.c        **** // Length: 6 bytes
  47:main.c        **** //   Byte 0:  User program memory size, high byte
  48:main.c        **** //   Byte 1:  User program memory size, low byte   
  49:main.c        **** //   Byte 2:  Flash Pagesize in bytes
  50:main.c        **** //   Byte 3:  Page write timing in ms. 
  51:main.c        **** //    Bit 7 '0': Page erase time equals page write time
  52:main.c        **** //    Bit 7 '1': Page erase time equals page write time divided by 4
  53:main.c        **** //   Byte 4:  SIGNATURE_1
  54:main.c        **** //   Byte 5:  SIGNATURE_2 
  55:main.c        **** 
  56:main.c        **** PROGMEM const uint8_t configurationReply[6] = {
  57:main.c        ****   (((uint16_t)PROGMEM_SIZE) >> 8) & 0xff,
  58:main.c        ****   ((uint16_t)PROGMEM_SIZE) & 0xff,
  59:main.c        ****   SPM_PAGESIZE,
  60:main.c        ****   MICRONUCLEUS_WRITE_SLEEP,
  61:main.c        ****   SIGNATURE_1,
  62:main.c        ****   SIGNATURE_2
  63:main.c        **** };  
  64:main.c        **** 
  65:main.c        ****   typedef union {
  66:main.c        ****     uint16_t w;
  67:main.c        ****     uint8_t b[2];
  68:main.c        ****   } uint16_union_t;
  69:main.c        ****   
  70:main.c        **** #if OSCCAL_RESTORE_DEFAULT
  71:main.c        ****   register uint8_t      osccal_default  asm("r2");
  72:main.c        **** #endif 
  73:main.c        **** 
  74:main.c        **** register uint16_union_t currentAddress  asm("r4");  // r4/r5 current progmem address, used for eras
  75:main.c        **** register uint16_union_t idlePolls       asm("r6");  // r6/r7 idlecounter
  76:main.c        **** 
  77:main.c        **** // command system schedules functions to run in the main loop
  78:main.c        **** enum {
  79:main.c        ****   cmd_local_nop=0, 
  80:main.c        ****   cmd_device_info=0,
  81:main.c        ****   cmd_transfer_page=1,
  82:main.c        ****   cmd_erase_application=2,
  83:main.c        ****   cmd_write_data=3,
  84:main.c        ****   cmd_exit=4,
  85:main.c        ****   cmd_write_page=64  // internal commands start at 64
  86:main.c        **** };
  87:main.c        **** register uint8_t        command         asm("r3");  // bind command to r3 
  88:main.c        **** 
  89:main.c        **** // Definition of sei and cli without memory barrier keyword to prevent reloading of memory variable
  90:main.c        **** #define sei() asm volatile("sei")
  91:main.c        **** #define cli() asm volatile("cli")
  92:main.c        **** #define nop() asm volatile("nop")
  93:main.c        **** #define wdr() asm volatile("wdr")
  94:main.c        **** 
  95:main.c        **** // Use the old delay routines without NOP padding. This saves memory.
  96:main.c        **** #define __DELAY_BACKWARD_COMPATIBLE__   
GAS LISTING /tmp/ccLOy0FK.s 			page 5


  97:main.c        **** 
  98:main.c        **** /* ------------------------------------------------------------------------ */
  99:main.c        **** static inline void eraseApplication(void);
 100:main.c        **** static void writeFlashPage(void);
 101:main.c        **** static void writeWordToPageBuffer(uint16_t data);
 102:main.c        **** static uint8_t usbFunctionSetup(uint8_t data[8]);
 103:main.c        **** static inline void leaveBootloader(void);
 104:main.c        **** 
 105:main.c        **** // This function is never called, it is just here to suppress a compiler warning.
 106:main.c        **** USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq) { return 0; }
 107:main.c        **** 
 108:main.c        **** // erase all pages until bootloader, in reverse order (so our vectors stay in place for as long as 
 109:main.c        **** // to minimise the chance of leaving the device in a state where the bootloader wont run, if there'
 110:main.c        **** // during upload
 111:main.c        **** static inline void eraseApplication(void) {
 112:main.c        ****   uint16_t ptr = BOOTLOADER_ADDRESS;
 113:main.c        **** 
 114:main.c        ****   while (ptr) {
 115:main.c        **** #if (defined __AVR_ATtiny841__)||(defined __AVR_ATtiny441__)    
 116:main.c        ****     ptr -= SPM_PAGESIZE * 4;        
 117:main.c        **** #else
 118:main.c        ****     ptr -= SPM_PAGESIZE;        
 119:main.c        **** #endif    
 120:main.c        ****     boot_page_erase(ptr);
 121:main.c        ****   }
 122:main.c        ****   
 123:main.c        ****   // Reset address to ensure the reset vector is written first.
 124:main.c        ****   currentAddress.w = 0;   
 125:main.c        **** }
 126:main.c        **** 
 127:main.c        **** // simply write currently stored page in to already erased flash memory
 128:main.c        **** static inline void writeFlashPage(void) {
 129:main.c        ****   if (currentAddress.w - 2 <BOOTLOADER_ADDRESS)
 130:main.c        ****       boot_page_write(currentAddress.w - 2);   // will halt CPU, no waiting required
 131:main.c        **** }
 132:main.c        **** 
 133:main.c        **** // Write a word into the page buffer.
 134:main.c        **** // Will patch the bootloader reset vector into the main vectortable to ensure
 135:main.c        **** // the device can not be bricked. Saving user-reset-vector is done in the host 
 136:main.c        **** // tool, starting with firmware V2
 137:main.c        **** static void writeWordToPageBuffer(uint16_t data) {
 133               		.stabn	68,0,137,.LM0-.LFBB1
 134               	.LM0:
 135               	.LFBB1:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 138:main.c        **** 
 139:main.c        **** #ifndef ENABLE_UNSAFE_OPTIMIZATIONS     
 140:main.c        ****   #if BOOTLOADER_ADDRESS < 8192
 141:main.c        ****   // rjmp
 142:main.c        ****   if (currentAddress.w == RESET_VECTOR_OFFSET * 2) {
 140               		.stabn	68,0,142,.LM1-.LFBB1
 141               	.LM1:
 142 0000 F201      		movw r30,r4
 143 0002 3097      		sbiw r30,0
GAS LISTING /tmp/ccLOy0FK.s 			page 6


 144 0004 01F0      		breq .L3
 143:main.c        ****     data = 0xC000 + (BOOTLOADER_ADDRESS/2) - 1;
 144:main.c        ****   }
 145:main.c        ****   #else
 146:main.c        ****   // far jmp
 147:main.c        ****   if (currentAddress.w == RESET_VECTOR_OFFSET * 2) {
 148:main.c        ****     data = 0x940c;
 149:main.c        ****   } else if (currentAddress.w == (RESET_VECTOR_OFFSET +1 ) * 2) {
 150:main.c        ****     data = (BOOTLOADER_ADDRESS/2);
 151:main.c        ****   }    
 152:main.c        ****   #endif
 153:main.c        **** #endif
 154:main.c        **** 
 155:main.c        **** #if OSCCAL_SAVE_CALIB
 156:main.c        ****    if (currentAddress.w == BOOTLOADER_ADDRESS - TINYVECTOR_OSCCAL_OFFSET) {
 145               		.stabn	68,0,156,.LM2-.LFBB1
 146               	.LM2:
 147 0006 2AEB      		ldi r18,-70
 148 0008 4216      		cp r4,r18
 149 000a 29E1      		ldi r18,25
 150 000c 5206      		cpc r5,r18
 151 000e 01F4      		brne .L2
 157:main.c        ****       data = OSCCAL;
 152               		.stabn	68,0,157,.LM3-.LFBB1
 153               	.LM3:
 154 0010 81B7      		in r24,0x31
 155 0012 90E0      		ldi r25,0
 156 0014 00C0      		rjmp .L2
 157               	.L3:
 143:main.c        ****     data = 0xC000 + (BOOTLOADER_ADDRESS/2) - 1;
 158               		.stabn	68,0,143,.LM4-.LFBB1
 159               	.LM4:
 160 0016 8FED      		ldi r24,lo8(-33)
 161 0018 9CEC      		ldi r25,lo8(-52)
 162               	.L2:
 158:main.c        ****    }     
 159:main.c        **** #endif
 160:main.c        ****   
 161:main.c        ****   boot_page_fill(currentAddress.w, data);
 163               		.stabn	68,0,161,.LM5-.LFBB1
 164               	.LM5:
 165 001a 21E0      		ldi r18,lo8(1)
 166               	/* #APP */
 167               	 ;  161 "main.c" 1
 168 001c 0C01      		movw  r0, r24
 169 001e 2093 5700 		sts 87, r18
 170 0022 E895      		spm
 171 0024 1124      		clr  r1
 172               		
 173               	 ;  0 "" 2
 162:main.c        ****   currentAddress.w += 2;
 174               		.stabn	68,0,162,.LM6-.LFBB1
 175               	.LM6:
 176               	/* #NOAPP */
 177 0026 CF01      		movw r24,r30
 178 0028 0296      		adiw r24,2
 179 002a 2C01      		movw r4,r24
GAS LISTING /tmp/ccLOy0FK.s 			page 7


 180 002c 0895      		ret
 181               		.size	writeWordToPageBuffer, .-writeWordToPageBuffer
 182               	.Lscope1:
 183               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 184               		.stabd	78,0,0
 185               		.section	.text.initHardware,"ax",@progbits
 186               		.stabs	"initHardware:f(0,47)",36,0,197,initHardware
 187               		.type	initHardware, @function
 188               	initHardware:
 189               		.stabd	46,0,0
 163:main.c        **** }
 164:main.c        **** 
 165:main.c        **** /* ------------------------------------------------------------------------ */
 166:main.c        **** static uint8_t usbFunctionSetup(uint8_t data[8]) {
 167:main.c        ****   usbRequest_t *rq = (void *)data;
 168:main.c        ****  
 169:main.c        ****   if (rq->bRequest == cmd_device_info) { // get device info
 170:main.c        ****     usbMsgPtr = (usbMsgPtr_t)configurationReply;
 171:main.c        ****     return sizeof(configurationReply);      
 172:main.c        ****   } else if (rq->bRequest == cmd_transfer_page) { 
 173:main.c        ****       // Set page address. Address zero always has to be written first to ensure reset vector patch
 174:main.c        ****       // Mask to page boundary to prevent vulnerability to partial page write "attacks"
 175:main.c        ****         if ( currentAddress.w != 0 ) {
 176:main.c        ****             currentAddress.b[0]=rq->wIndex.bytes[0] & (~ (SPM_PAGESIZE-1));     
 177:main.c        ****             currentAddress.b[1]=rq->wIndex.bytes[1];     
 178:main.c        ****             
 179:main.c        ****             // clear page buffer as a precaution before filling the buffer in case 
 180:main.c        ****             // a previous write operation failed and there is still something in the buffer.       
 181:main.c        ****             __SPM_REG=(_BV(CTPB)|_BV(__SPM_ENABLE));
 182:main.c        ****             asm volatile("spm");
 183:main.c        ****             
 184:main.c        ****         }        
 185:main.c        ****     } else if (rq->bRequest == cmd_write_data) { // Write data
 186:main.c        ****       writeWordToPageBuffer(rq->wValue.word);
 187:main.c        ****       writeWordToPageBuffer(rq->wIndex.word);
 188:main.c        ****       if ((currentAddress.b[0] % SPM_PAGESIZE) == 0)
 189:main.c        ****           command=cmd_write_page; // ask runloop to write our page       
 190:main.c        ****   } else {
 191:main.c        ****     // Handle cmd_erase_application and cmd_exit
 192:main.c        ****     command=rq->bRequest&0x3f;    
 193:main.c        ****   }
 194:main.c        ****   return 0;
 195:main.c        **** }
 196:main.c        **** 
 197:main.c        **** static void initHardware (void)
 198:main.c        **** {
 190               		.stabn	68,0,198,.LM7-.LFBB2
 191               	.LM7:
 192               	.LFBB2:
 193               	/* prologue: function */
 194               	/* frame size = 0 */
 195               	/* stack size = 0 */
 196               	.L__stack_usage = 0
 199:main.c        ****   // Disable watchdog and set timeout to maximum in case the WDT is fused on 
 200:main.c        **** #ifdef CCP
 201:main.c        ****   // New ATtinies841/441 use a different unlock sequence and renamed registers
 202:main.c        ****   MCUSR=0;    
GAS LISTING /tmp/ccLOy0FK.s 			page 8


 203:main.c        ****   CCP = 0xD8; 
 204:main.c        ****   WDTCSR = 1<<WDP2 | 1<<WDP1 | 1<<WDP0; 
 205:main.c        **** #else
 206:main.c        ****   MCUSR=0;    
 197               		.stabn	68,0,206,.LM8-.LFBB2
 198               	.LM8:
 199 0000 14BE      		out 0x34,__zero_reg__
 207:main.c        ****   WDTCR = 1<<WDCE | 1<<WDE;
 200               		.stabn	68,0,207,.LM9-.LFBB2
 201               	.LM9:
 202 0002 88E1      		ldi r24,lo8(24)
 203 0004 81BD      		out 0x21,r24
 208:main.c        ****   WDTCR = 1<<WDP2 | 1<<WDP1 | 1<<WDP0; 
 204               		.stabn	68,0,208,.LM10-.LFBB2
 205               	.LM10:
 206 0006 87E0      		ldi r24,lo8(7)
 207 0008 81BD      		out 0x21,r24
 209:main.c        **** #endif  
 210:main.c        **** 
 211:main.c        ****   
 212:main.c        ****   usbDeviceDisconnect();  /* do this while interrupts are disabled */
 208               		.stabn	68,0,212,.LM11-.LFBB2
 209               	.LM11:
 210 000a BB9A      		sbi 0x17,3
 211               	.LBB29:
 212               	.LBB30:
 213               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext1
 214               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
GAS LISTING /tmp/ccLOy0FK.s 			page 9


  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
GAS LISTING /tmp/ccLOy0FK.s 			page 10


  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
GAS LISTING /tmp/ccLOy0FK.s 			page 11


 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 215               		.stabn	68,0,163,.LM12-.LFBB2
 216               	.LM12:
 217 000c 2FE2      		ldi r18,lo8(989999)
 218 000e 8BE1      		ldi r24,hi8(989999)
 219 0010 9FE0      		ldi r25,hlo8(989999)
 220 0012 2150      	1:	subi r18,1
 221 0014 8040      		sbci r24,0
 222 0016 9040      		sbci r25,0
 223 0018 01F4      		brne 1b
 224 001a 00C0      		rjmp .
 225 001c 0000      		nop
 226               	.LBE30:
 227               	.LBE29:
 228               		.stabs	"main.c",132,0,0,.Ltext2
 229               	.Ltext2:
 213:main.c        ****   _delay_ms(300);  
 214:main.c        ****   usbDeviceConnect();
 230               		.stabn	68,0,214,.LM13-.LFBB2
 231               	.LM13:
 232 001e BB98      		cbi 0x17,3
 233               	.LBB31:
 234               	.LBB32:
 235               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext3
 236               	.Ltext3:
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  *
   7:usbdrv/usbdrv.c ****  
   8:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   9:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
  10:usbdrv/usbdrv.c ****  */
  11:usbdrv/usbdrv.c **** 
  12:usbdrv/usbdrv.c **** /* This copy of usbdrv.c was optimized to reduce the memory footprint with micronucleus V2
  13:usbdrv/usbdrv.c ****  *
GAS LISTING /tmp/ccLOy0FK.s 			page 12


  14:usbdrv/usbdrv.c ****  * Changes: 
  15:usbdrv/usbdrv.c ****  *     a) Replies to USB SETUP IN Packets are now only possible from Flash
  16:usbdrv/usbdrv.c ****  *       * Commented out routines to copy from SRAM
  17:usbdrv/usbdrv.c ****  *       * remove msgflag variable and all handling involving it
  18:usbdrv/usbdrv.c ****  */ 
  19:usbdrv/usbdrv.c **** #define MNHACK_ONLY_FLASH_MSGPTR                
  20:usbdrv/usbdrv.c **** /*     b) Do not use preinitialized global variables to avoid having to initialize
  21:usbdrv/usbdrv.c ****  *        the data section.
  22:usbdrv/usbdrv.c ****  */
  23:usbdrv/usbdrv.c **** #define MNHACK_NO_DATASECTION   
  24:usbdrv/usbdrv.c ****  
  25:usbdrv/usbdrv.c **** #include "usbdrv.h"
  26:usbdrv/usbdrv.c **** #include "oddebug.h"
  27:usbdrv/usbdrv.c **** 
  28:usbdrv/usbdrv.c **** /*
  29:usbdrv/usbdrv.c **** General Description:
  30:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  31:usbdrv/usbdrv.c **** documentation of the entire driver.
  32:usbdrv/usbdrv.c **** */
  33:usbdrv/usbdrv.c **** 
  34:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  35:usbdrv/usbdrv.c **** 
  36:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  37:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  38:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  39:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  40:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  41:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  42:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  43:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  44:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  45:usbdrv/usbdrv.c **** #ifdef MNHACK_NO_DATASECTION
  46:usbdrv/usbdrv.c ****   volatile uchar usbTxLen;   /* number of bytes to transmit with next IN token or handshake token *
  47:usbdrv/usbdrv.c **** #else
  48:usbdrv/usbdrv.c ****   volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or hand
  49:usbdrv/usbdrv.c **** #endif
  50:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  51:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  52:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  53:usbdrv/usbdrv.c **** #endif
  54:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  55:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  56:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  57:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  58:usbdrv/usbdrv.c **** #   endif
  59:usbdrv/usbdrv.c **** #endif
  60:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  61:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  62:usbdrv/usbdrv.c **** #endif
  63:usbdrv/usbdrv.c **** 
  64:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  65:usbdrv/usbdrv.c **** usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
  66:usbdrv/usbdrv.c **** #ifdef MNHACK_NO_DATASECTION
  67:usbdrv/usbdrv.c ****   static usbMsgLen_t  usbMsgLen; /* remaining number of bytes */
  68:usbdrv/usbdrv.c **** #else
  69:usbdrv/usbdrv.c ****   static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  70:usbdrv/usbdrv.c **** #endif
GAS LISTING /tmp/ccLOy0FK.s 			page 13


  71:usbdrv/usbdrv.c ****   
  72:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR                
  73:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  74:usbdrv/usbdrv.c **** #endif
  75:usbdrv/usbdrv.c **** 
  76:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  77:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  78:usbdrv/usbdrv.c **** 
  79:usbdrv/usbdrv.c **** /*
  80:usbdrv/usbdrv.c **** optimizing hints:
  81:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  82:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  83:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  84:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  85:usbdrv/usbdrv.c **** */
  86:usbdrv/usbdrv.c **** 
  87:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  88:usbdrv/usbdrv.c **** 
  89:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  90:usbdrv/usbdrv.c **** 
  91:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  92:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  93:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  94:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
  95:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  96:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  97:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  98:usbdrv/usbdrv.c **** };
  99:usbdrv/usbdrv.c **** #endif
 100:usbdrv/usbdrv.c **** 
 101:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
 102:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
 103:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
 104:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringVendor[] = {
 105:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
 106:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
 107:usbdrv/usbdrv.c **** };
 108:usbdrv/usbdrv.c **** #endif
 109:usbdrv/usbdrv.c **** 
 110:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
 111:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
 112:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
 113:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringDevice[] = {
 114:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
 116:usbdrv/usbdrv.c **** };
 117:usbdrv/usbdrv.c **** #endif
 118:usbdrv/usbdrv.c **** 
 119:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
 120:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
 121:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
 122:usbdrv/usbdrv.c **** PROGMEM const int usbDescriptorStringSerialNumber[] = {
 123:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 124:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 125:usbdrv/usbdrv.c **** };
 126:usbdrv/usbdrv.c **** #endif
 127:usbdrv/usbdrv.c **** 
GAS LISTING /tmp/ccLOy0FK.s 			page 14


 128:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 129:usbdrv/usbdrv.c **** 
 130:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 133:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 134:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 135:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
 136:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 137:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 138:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 139:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 140:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 141:usbdrv/usbdrv.c ****     0,                      /* protocol */
 142:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 143:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 144:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 145:usbdrv/usbdrv.c ****      */
 146:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 147:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 148:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 149:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 150:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 151:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 152:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 153:usbdrv/usbdrv.c **** };
 154:usbdrv/usbdrv.c **** #endif
 155:usbdrv/usbdrv.c **** 
 156:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 157:usbdrv/usbdrv.c **** 
 158:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 159:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 160:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 161:usbdrv/usbdrv.c **** #endif
 162:usbdrv/usbdrv.c **** 
 163:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 164:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 165:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 166:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 167:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 168:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 169:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 170:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 171:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 172:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 173:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 174:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 175:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 176:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 177:usbdrv/usbdrv.c **** #else
 178:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 179:usbdrv/usbdrv.c **** #endif
 180:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 181:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 182:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 183:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 184:usbdrv/usbdrv.c ****     0,          /* index of this interface */
GAS LISTING /tmp/ccLOy0FK.s 			page 15


 185:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 186:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 187:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 188:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 189:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 190:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 191:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 192:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 193:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 194:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 195:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 196:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 197:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 198:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 199:usbdrv/usbdrv.c **** #endif
 200:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 201:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 202:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 203:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 204:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 205:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 206:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 207:usbdrv/usbdrv.c **** #endif
 208:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 209:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 210:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 211:usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 212:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 213:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 214:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 215:usbdrv/usbdrv.c **** #endif
 216:usbdrv/usbdrv.c **** };
 217:usbdrv/usbdrv.c **** #endif
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 220:usbdrv/usbdrv.c **** 
 221:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 224:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 225:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 226:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 227:usbdrv/usbdrv.c **** #   endif
 228:usbdrv/usbdrv.c **** #endif
 229:usbdrv/usbdrv.c **** }
 230:usbdrv/usbdrv.c **** 
 231:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 232:usbdrv/usbdrv.c **** {
 233:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 234:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 235:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 236:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 237:usbdrv/usbdrv.c **** #endif
 238:usbdrv/usbdrv.c **** #endif
 239:usbdrv/usbdrv.c **** }
 240:usbdrv/usbdrv.c **** 
 241:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
GAS LISTING /tmp/ccLOy0FK.s 			page 16


 242:usbdrv/usbdrv.c **** 
 243:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 244:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 245:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 246:usbdrv/usbdrv.c **** {
 247:usbdrv/usbdrv.c **** uchar   *p;
 248:usbdrv/usbdrv.c **** char    i;
 249:usbdrv/usbdrv.c **** 
 250:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 251:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 252:usbdrv/usbdrv.c ****         return;
 253:usbdrv/usbdrv.c **** #endif
 254:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 255:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 256:usbdrv/usbdrv.c ****     }else{
 257:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 258:usbdrv/usbdrv.c ****     }
 259:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 260:usbdrv/usbdrv.c ****     i = len;
 261:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 262:usbdrv/usbdrv.c ****         *p++ = *data++;
 263:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 264:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 265:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 266:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 267:usbdrv/usbdrv.c **** }
 268:usbdrv/usbdrv.c **** 
 269:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 270:usbdrv/usbdrv.c **** {
 271:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 272:usbdrv/usbdrv.c **** }
 273:usbdrv/usbdrv.c **** #endif
 274:usbdrv/usbdrv.c **** 
 275:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 276:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 277:usbdrv/usbdrv.c **** {
 278:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 279:usbdrv/usbdrv.c **** }
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 282:usbdrv/usbdrv.c **** 
 283:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 284:usbdrv/usbdrv.c **** 
 285:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 286:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 287:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 288:usbdrv/usbdrv.c ****  * cases.
 289:usbdrv/usbdrv.c ****  */
 290:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 291:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 292:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 293:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 294:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 295:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 296:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 297:usbdrv/usbdrv.c **** #else
 298:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
GAS LISTING /tmp/ccLOy0FK.s 			page 17


 299:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 300:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 301:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || _cmd == (v3)){
 302:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 303:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 304:usbdrv/usbdrv.c **** #endif
 305:usbdrv/usbdrv.c **** 
 306:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 307:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 308:usbdrv/usbdrv.c **** #endif
 309:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 310:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 311:usbdrv/usbdrv.c **** #endif
 312:usbdrv/usbdrv.c **** 
 313:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 314:usbdrv/usbdrv.c **** 
 315:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 316:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 317:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 318:usbdrv/usbdrv.c ****  * optimizing!
 319:usbdrv/usbdrv.c ****  */
 320:usbdrv/usbdrv.c **** 
 321:usbdrv/usbdrv.c ****   #define GET_DESCRIPTOR(cfgProp, staticName)         \
 322:usbdrv/usbdrv.c ****       if(cfgProp){                                    \
 323:usbdrv/usbdrv.c ****           if((cfgProp) & USB_PROP_IS_RAM)             \
 324:usbdrv/usbdrv.c ****               flags = 0;                              \
 325:usbdrv/usbdrv.c ****           if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 326:usbdrv/usbdrv.c ****               len = usbFunctionDescriptor(rq);        \
 327:usbdrv/usbdrv.c ****           }else{                                      \
 328:usbdrv/usbdrv.c ****               len = USB_PROP_LENGTH(cfgProp);         \
 329:usbdrv/usbdrv.c ****               usbMsgPtr = (usbMsgPtr_t)(staticName);  \
 330:usbdrv/usbdrv.c ****           }                                           \
 331:usbdrv/usbdrv.c ****       }
 332:usbdrv/usbdrv.c **** 
 333:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 334:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 335:usbdrv/usbdrv.c ****  */
 336:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 337:usbdrv/usbdrv.c **** {
 338:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 339:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 340:usbdrv/usbdrv.c **** 
 341:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 342:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 343:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 344:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 345:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 346:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 347:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 348:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 349:usbdrv/usbdrv.c ****             flags = 0;
 350:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 352:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 353:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 354:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 355:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
GAS LISTING /tmp/ccLOy0FK.s 			page 18


 356:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 357:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 358:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 359:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 360:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 361:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 362:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 363:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 364:usbdrv/usbdrv.c ****             }
 365:usbdrv/usbdrv.c ****         SWITCH_END
 366:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 367:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 368:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 369:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 370:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 371:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 372:usbdrv/usbdrv.c **** #endif
 373:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 374:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 375:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 376:usbdrv/usbdrv.c ****         }
 377:usbdrv/usbdrv.c ****     SWITCH_END
 378:usbdrv/usbdrv.c ****     
 379:usbdrv/usbdrv.c ****     flags=flags;  // Make compiler shut up about unused variable
 380:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR                
 381:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 382:usbdrv/usbdrv.c **** #endif    
 383:usbdrv/usbdrv.c ****     return len;
 384:usbdrv/usbdrv.c **** }
 385:usbdrv/usbdrv.c **** 
 386:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 387:usbdrv/usbdrv.c **** 
 388:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 389:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 390:usbdrv/usbdrv.c ****  */
 391:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 392:usbdrv/usbdrv.c **** {
 393:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 394:usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 395:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 396:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 397:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 398:usbdrv/usbdrv.c **** #endif
 399:usbdrv/usbdrv.c **** 
 400:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 401:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 402:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 403:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 404:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 405:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 406:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 407:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 408:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 409:usbdrv/usbdrv.c **** #endif
 410:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 411:usbdrv/usbdrv.c ****         len = 2;
 412:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
GAS LISTING /tmp/ccLOy0FK.s 			page 19


 413:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 414:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 415:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 416:usbdrv/usbdrv.c ****             usbResetDataToggling();
 417:usbdrv/usbdrv.c ****         }
 418:usbdrv/usbdrv.c **** #endif
 419:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 420:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 421:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 422:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 423:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 424:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 425:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 426:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 427:usbdrv/usbdrv.c ****         len = 1;
 428:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 429:usbdrv/usbdrv.c ****         usbConfiguration = value;
 430:usbdrv/usbdrv.c ****         usbResetStall();
 431:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 432:usbdrv/usbdrv.c ****         len = 1;
 433:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 434:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 435:usbdrv/usbdrv.c ****         usbResetDataToggling();
 436:usbdrv/usbdrv.c ****         usbResetStall();
 437:usbdrv/usbdrv.c **** #endif
 438:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 439:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 440:usbdrv/usbdrv.c ****     SWITCH_END
 441:usbdrv/usbdrv.c ****     usbMsgPtr = (usbMsgPtr_t)dataPtr;
 442:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 443:usbdrv/usbdrv.c ****     return len;
 444:usbdrv/usbdrv.c **** }
 445:usbdrv/usbdrv.c **** 
 446:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 447:usbdrv/usbdrv.c **** 
 448:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 449:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 450:usbdrv/usbdrv.c ****  * them accordingly.
 451:usbdrv/usbdrv.c ****  */
 452:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 453:usbdrv/usbdrv.c **** {
 454:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 455:usbdrv/usbdrv.c **** 
 456:usbdrv/usbdrv.c **** /* usbRxToken can be:
 457:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 458:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 459:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 460:usbdrv/usbdrv.c ****  */
 461:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 462:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 463:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 464:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 465:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 466:usbdrv/usbdrv.c ****         return;
 467:usbdrv/usbdrv.c ****     }
 468:usbdrv/usbdrv.c **** #endif
 469:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
GAS LISTING /tmp/ccLOy0FK.s 			page 20


 470:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 471:usbdrv/usbdrv.c ****             return;
 472:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 473:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 474:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 475:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 476:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 477:usbdrv/usbdrv.c **** #endif        
 478:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 479:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 480:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 481:usbdrv/usbdrv.c ****         }else{
 482:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 483:usbdrv/usbdrv.c ****         }
 484:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 485:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 486:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 487:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 488:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 489:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 490:usbdrv/usbdrv.c ****                 }else{
 491:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 492:usbdrv/usbdrv.c ****                 }
 493:usbdrv/usbdrv.c ****             }
 494:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 495:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 496:usbdrv/usbdrv.c **** #endif
 497:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 498:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 499:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 500:usbdrv/usbdrv.c ****         }else{
 501:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 502:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 503:usbdrv/usbdrv.c ****         }
 504:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 505:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 506:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 507:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 508:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 509:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 510:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 511:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 512:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 513:usbdrv/usbdrv.c ****             }
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c **** #endif
 516:usbdrv/usbdrv.c ****     }
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 522:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 525:usbdrv/usbdrv.c **** {
 526:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
GAS LISTING /tmp/ccLOy0FK.s 			page 21


 527:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 528:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 529:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 530:usbdrv/usbdrv.c ****         }else
 531:usbdrv/usbdrv.c **** #endif
 532:usbdrv/usbdrv.c ****         {
 533:usbdrv/usbdrv.c ****             uchar i = len;
 534:usbdrv/usbdrv.c ****             usbMsgPtr_t r = usbMsgPtr;
 535:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 536:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 537:usbdrv/usbdrv.c **** #endif          
 538:usbdrv/usbdrv.c ****                 do{
 539:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 540:usbdrv/usbdrv.c ****                     *data++ = c;
 541:usbdrv/usbdrv.c ****                     r++;
 542:usbdrv/usbdrv.c ****                 }while(--i);
 543:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 544:usbdrv/usbdrv.c ****              }else{  // RAM data 
 545:usbdrv/usbdrv.c ****                 do{
 546:usbdrv/usbdrv.c ****                     *data++ = *((uchar *)r);
 547:usbdrv/usbdrv.c ****                     r++;
 548:usbdrv/usbdrv.c ****                 }while(--i);
 549:usbdrv/usbdrv.c ****             }
 550:usbdrv/usbdrv.c **** #endif                      
 551:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 552:usbdrv/usbdrv.c ****         }
 553:usbdrv/usbdrv.c ****     }
 554:usbdrv/usbdrv.c ****     return len;
 555:usbdrv/usbdrv.c **** }
 556:usbdrv/usbdrv.c **** 
 557:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 558:usbdrv/usbdrv.c **** 
 559:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 560:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 561:usbdrv/usbdrv.c ****  */
 562:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 563:usbdrv/usbdrv.c **** {
 564:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 565:usbdrv/usbdrv.c **** uchar       len;
 566:usbdrv/usbdrv.c **** 
 567:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 568:usbdrv/usbdrv.c ****     if(wantLen > 8)
 569:usbdrv/usbdrv.c ****         wantLen = 8;
 570:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 571:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 572:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 573:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 574:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 575:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 576:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 577:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 578:usbdrv/usbdrv.c ****     }else{
 579:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 580:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 581:usbdrv/usbdrv.c ****     }
 582:usbdrv/usbdrv.c ****     usbTxLen = len;
 583:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
GAS LISTING /tmp/ccLOy0FK.s 			page 22


 584:usbdrv/usbdrv.c **** }
 585:usbdrv/usbdrv.c **** 
 586:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 587:usbdrv/usbdrv.c **** 
 588:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 589:usbdrv/usbdrv.c **** {
 590:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 591:usbdrv/usbdrv.c **** static uchar    wasReset;
 592:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 593:usbdrv/usbdrv.c **** 
 594:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 595:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 596:usbdrv/usbdrv.c ****         wasReset = isReset;
 597:usbdrv/usbdrv.c ****     }
 598:usbdrv/usbdrv.c **** #else
 599:usbdrv/usbdrv.c ****     notResetState = notResetState;  // avoid compiler warning
 600:usbdrv/usbdrv.c **** #endif
 601:usbdrv/usbdrv.c **** }
 602:usbdrv/usbdrv.c **** 
 603:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 606:usbdrv/usbdrv.c **** {
 607:usbdrv/usbdrv.c **** schar   len;
 608:usbdrv/usbdrv.c **** uchar   i;
 609:usbdrv/usbdrv.c **** 
 610:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 611:usbdrv/usbdrv.c ****     if(len >= 0){
 612:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 613:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 614:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 615:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 616:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 617:usbdrv/usbdrv.c ****  */
 618:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 619:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 620:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 621:usbdrv/usbdrv.c ****             usbRxLen = 0;
 622:usbdrv/usbdrv.c **** #else
 623:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 624:usbdrv/usbdrv.c **** #endif
 625:usbdrv/usbdrv.c ****     }
 626:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 627:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 628:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 629:usbdrv/usbdrv.c ****         }
 630:usbdrv/usbdrv.c ****     }
 631:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 632:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 633:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 634:usbdrv/usbdrv.c ****             goto isNotReset;
 635:usbdrv/usbdrv.c ****     }
 636:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 637:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 638:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 639:usbdrv/usbdrv.c ****     usbResetStall();
 640:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
GAS LISTING /tmp/ccLOy0FK.s 			page 23


 641:usbdrv/usbdrv.c **** isNotReset:
 642:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 643:usbdrv/usbdrv.c **** }
 644:usbdrv/usbdrv.c **** 
 645:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 646:usbdrv/usbdrv.c **** 
 647:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 648:usbdrv/usbdrv.c **** {
 649:usbdrv/usbdrv.c **** #ifdef MNHACK_NO_DATASECTION   
 650:usbdrv/usbdrv.c ****     usbTxLen = USBPID_NAK;
 237               		.stabn	68,0,650,.LM14-.LFBB2
 238               	.LM14:
 239 0020 8AE5      		ldi r24,lo8(90)
 240 0022 8093 0000 		sts usbTxLen,r24
 651:usbdrv/usbdrv.c ****     usbMsgLen = USB_NO_MSG;
 241               		.stabn	68,0,651,.LM15-.LFBB2
 242               	.LM15:
 243 0026 8FEF      		ldi r24,lo8(-1)
 244 0028 8093 0000 		sts usbMsgLen,r24
 652:usbdrv/usbdrv.c **** #endif
 653:usbdrv/usbdrv.c ****     
 654:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 655:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 245               		.stabn	68,0,655,.LM16-.LFBB2
 246               	.LM16:
 247 002c AC9A      		sbi 0x15,4
 656:usbdrv/usbdrv.c **** #endif
 657:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 658:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 659:usbdrv/usbdrv.c **** #endif
 660:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 248               		.stabn	68,0,660,.LM17-.LFBB2
 249               	.LM17:
 250 002e 8BB7      		in r24,0x3b
 251 0030 8062      		ori r24,lo8(32)
 252 0032 8BBF      		out 0x3b,r24
 253 0034 0895      		ret
 254               	.LBE32:
 255               	.LBE31:
 256               		.size	initHardware, .-initHardware
 257               	.Lscope2:
 258               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 259               		.stabd	78,0,0
 260               		.section	.text.startup.main,"ax",@progbits
 261               		.stabs	"main:F(0,1)",36,0,237,main
 262               	.global	main
 263               		.type	main, @function
 264               	main:
 265               		.stabd	46,0,0
 266               		.stabs	"main.c",132,0,0,.Ltext4
 267               	.Ltext4:
 215:main.c        **** 
 216:main.c        ****   usbInit();    // Initialize INT settings after reconnect
 217:main.c        **** }
 218:main.c        **** 
 219:main.c        **** /* ------------------------------------------------------------------------ */
 220:main.c        **** // reset system to a normal state and launch user program
GAS LISTING /tmp/ccLOy0FK.s 			page 24


 221:main.c        **** static void leaveBootloader(void) __attribute__((__noreturn__));
 222:main.c        **** static inline void leaveBootloader(void) {
 223:main.c        ****  
 224:main.c        ****   bootLoaderExit();
 225:main.c        **** 
 226:main.c        **** #if OSCCAL_RESTORE_DEFAULT
 227:main.c        ****   OSCCAL=osccal_default;
 228:main.c        ****   nop(); // NOP to avoid CPU hickup during oscillator stabilization
 229:main.c        **** #endif
 230:main.c        ****     
 231:main.c        ****  asm volatile ("rjmp __vectors - 4"); // jump to application reset vector at end of flash
 232:main.c        ****   
 233:main.c        ****  for (;;); // Make sure function does not return to help compiler optimize
 234:main.c        **** }
 235:main.c        **** 
 236:main.c        **** void USB_INTR_VECTOR(void);
 237:main.c        **** int main(void) {
 268               		.stabn	68,0,237,.LM18-.LFBB3
 269               	.LM18:
 270               	.LFBB3:
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 0 */
 274               	.L__stack_usage = 0
 275               	.LBB64:
 238:main.c        ****   uint8_t osccal_tmp;
 239:main.c        ****   
 240:main.c        ****   bootLoaderInit();
 241:main.c        ****   
 242:main.c        ****   /* save default OSCCAL calibration  */
 243:main.c        **** #if OSCCAL_RESTORE_DEFAULT
 244:main.c        ****   osccal_default = OSCCAL;
 245:main.c        **** #endif
 246:main.c        ****   
 247:main.c        **** #if OSCCAL_SAVE_CALIB
 248:main.c        ****   // adjust clock to previous calibration value, so bootloader starts with proper clock calibration
 249:main.c        ****   unsigned char stored_osc_calibration = pgm_read_byte(BOOTLOADER_ADDRESS - TINYVECTOR_OSCCAL_OFFSE
 276               		.stabn	68,0,249,.LM19-.LFBB3
 277               	.LM19:
 278 0000 EAEB      		ldi r30,lo8(-70)
 279 0002 F9E1      		ldi r31,lo8(25)
 280               	/* #APP */
 281               	 ;  249 "main.c" 1
 282 0004 E491      		lpm r30, Z
 283               		
 284               	 ;  0 "" 2
 285               	/* #NOAPP */
 286               	.LBE64:
 250:main.c        ****   if (stored_osc_calibration != 0xFF) {
 287               		.stabn	68,0,250,.LM20-.LFBB3
 288               	.LM20:
 289 0006 EF3F      		cpi r30,lo8(-1)
 290 0008 01F0      		breq .L7
 251:main.c        ****     OSCCAL=stored_osc_calibration;
 291               		.stabn	68,0,251,.LM21-.LFBB3
 292               	.LM21:
 293 000a E1BF      		out 0x31,r30
GAS LISTING /tmp/ccLOy0FK.s 			page 25


 252:main.c        ****     nop();
 294               		.stabn	68,0,252,.LM22-.LFBB3
 295               	.LM22:
 296               	/* #APP */
 297               	 ;  252 "main.c" 1
 298 000c 0000      		nop
 299               	 ;  0 "" 2
 300               	/* #NOAPP */
 301               	.L7:
 253:main.c        ****   }
 254:main.c        **** #endif
 255:main.c        ****   
 256:main.c        ****   if (bootLoaderStartCondition()||(pgm_read_byte(BOOTLOADER_ADDRESS - TINYVECTOR_RESET_OFFSET + 1)=
 257:main.c        ****   
 258:main.c        ****     initHardware();        
 302               		.stabn	68,0,258,.LM23-.LFBB3
 303               	.LM23:
 304 000e 00D0      		rcall initHardware
 259:main.c        ****     LED_INIT();
 260:main.c        **** 
 261:main.c        ****     if (AUTO_EXIT_NO_USB_MS>0) {
 262:main.c        ****       idlePolls.b[1]=((AUTO_EXIT_MS-AUTO_EXIT_NO_USB_MS)/5)>>8;
 263:main.c        ****     } else {
 264:main.c        ****       idlePolls.b[1]=0;
 305               		.stabn	68,0,264,.LM24-.LFBB3
 306               	.LM24:
 307 0010 712C      		mov r7,__zero_reg__
 265:main.c        ****     }
 266:main.c        ****     
 267:main.c        ****     command=cmd_local_nop;     
 308               		.stabn	68,0,267,.LM25-.LFBB3
 309               	.LM25:
 310 0012 312C      		mov r3,__zero_reg__
 268:main.c        ****     currentAddress.w = 0;
 311               		.stabn	68,0,268,.LM26-.LFBB3
 312               	.LM26:
 313 0014 412C      		mov r4,__zero_reg__
 314 0016 512C      		mov r5,__zero_reg__
 315               	.L44:
 237:main.c        ****   uint8_t osccal_tmp;
 316               		.stabn	68,0,237,.LM27-.LFBB3
 317               	.LM27:
 318 0018 CCE7      		ldi r28,lo8(124)
 319 001a D5E1      		ldi r29,lo8(21)
 320               	.LBB65:
 269:main.c        ****     
 270:main.c        ****     do {
 271:main.c        ****       // 15 clockcycles per loop.     
 272:main.c        ****       // adjust fastctr for 5ms timeout
 273:main.c        ****       
 274:main.c        ****       uint16_t fastctr=(uint16_t)(F_CPU/(1000.0f*15.0f/5.0f));
 275:main.c        ****       uint8_t  resetctr=100;
 321               		.stabn	68,0,275,.LM28-.LFBB3
 322               	.LM28:
 323 001c 14E6      		ldi r17,lo8(100)
 324               	.L12:
 276:main.c        ****   
GAS LISTING /tmp/ccLOy0FK.s 			page 26


 277:main.c        ****       do {        
 278:main.c        ****         if ((USBIN & USBMASK) !=0) resetctr=100;
 325               		.stabn	68,0,278,.LM29-.LFBB3
 326               	.LM29:
 327 001e 86B3      		in r24,0x16
 328 0020 8871      		andi r24,lo8(24)
 329 0022 01F0      		breq .L8
 330 0024 14E6      		ldi r17,lo8(100)
 331               	.L8:
 279:main.c        ****         
 280:main.c        ****         if (!--resetctr) { // reset encountered
 332               		.stabn	68,0,280,.LM30-.LFBB3
 333               	.LM30:
 334 0026 1150      		subi r17,lo8(-(-1))
 335 0028 01F4      		brne .L9
 281:main.c        ****            usbNewDeviceAddr = 0;   // bits from the reset handling of usbpoll()
 336               		.stabn	68,0,281,.LM31-.LFBB3
 337               	.LM31:
 338 002a 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 282:main.c        ****            usbDeviceAddr = 0;
 339               		.stabn	68,0,282,.LM32-.LFBB3
 340               	.LM32:
 341 002e 1092 0000 		sts usbDeviceAddr,__zero_reg__
 283:main.c        **** #if (OSCCAL_HAVE_XTAL == 0)           
 284:main.c        ****            calibrateOscillatorASM();   
 342               		.stabn	68,0,284,.LM33-.LFBB3
 343               	.LM33:
 344 0032 00D0      		rcall calibrateOscillatorASM
 345               	.L9:
 285:main.c        **** #endif           
 286:main.c        ****         }
 287:main.c        ****         
 288:main.c        ****         if (USB_INTR_PENDING & (1<<USB_INTR_PENDING_BIT)) {
 346               		.stabn	68,0,288,.LM34-.LFBB3
 347               	.LM34:
 348 0034 0AB6      		in __tmp_reg__,0x3a
 349 0036 05FE      		sbrs __tmp_reg__,5
 350 0038 00C0      		rjmp .L10
 289:main.c        ****           USB_INTR_VECTOR();  
 351               		.stabn	68,0,289,.LM35-.LFBB3
 352               	.LM35:
 353 003a 00D0      		rcall __vector_2
 290:main.c        ****           USB_INTR_PENDING = 1<<USB_INTR_PENDING_BIT;  // Clear int pending, in case timeout occure
 354               		.stabn	68,0,290,.LM36-.LFBB3
 355               	.LM36:
 356 003c 80E2      		ldi r24,lo8(32)
 357 003e 8ABF      		out 0x3a,r24
 291:main.c        ****           idlePolls.b[1]=0; // reset idle polls when we get usb traffic
 358               		.stabn	68,0,291,.LM37-.LFBB3
 359               	.LM37:
 360 0040 712C      		mov r7,__zero_reg__
 292:main.c        ****          break;
 361               		.stabn	68,0,292,.LM38-.LFBB3
 362               	.LM38:
 363 0042 00C0      		rjmp .L11
 364               	.L10:
 365 0044 2197      		sbiw r28,1
GAS LISTING /tmp/ccLOy0FK.s 			page 27


 293:main.c        ****         }
 294:main.c        ****         
 295:main.c        ****       } while(--fastctr);     
 366               		.stabn	68,0,295,.LM39-.LFBB3
 367               	.LM39:
 368 0046 01F4      		brne .L12
 369 0048 C0E0      		ldi r28,0
 370 004a D0E0      		ldi r29,0
 371               	.L11:
 296:main.c        ****       
 297:main.c        ****       wdr();
 372               		.stabn	68,0,297,.LM40-.LFBB3
 373               	.LM40:
 374               	/* #APP */
 375               	 ;  297 "main.c" 1
 376 004c A895      		wdr
 377               	 ;  0 "" 2
 298:main.c        ****       
 299:main.c        ****  #if OSCCAL_SLOW_PROGRAMMING
 300:main.c        ****       osccal_tmp  = OSCCAL;
 301:main.c        ****       OSCCAL      = osccal_default;
 302:main.c        ****  #endif
 303:main.c        ****       // commands are only evaluated after next USB transmission or after 5 ms passed
 304:main.c        ****       if (command==cmd_erase_application) 
 378               		.stabn	68,0,304,.LM41-.LFBB3
 379               	.LM41:
 380               	/* #NOAPP */
 381 004e 22E0      		ldi r18,lo8(2)
 382 0050 3212      		cpse r3,r18
 383 0052 00C0      		rjmp .L13
 384 0054 E0EC      		ldi r30,lo8(-64)
 385 0056 F9E1      		ldi r31,lo8(25)
 386               	.L14:
 387               	.LBB66:
 388               	.LBB67:
 118:main.c        **** #endif    
 389               		.stabn	68,0,118,.LM42-.LFBB3
 390               	.LM42:
 391 0058 E054      		subi r30,64
 392 005a F109      		sbc r31,__zero_reg__
 120:main.c        ****   }
 393               		.stabn	68,0,120,.LM43-.LFBB3
 394               	.LM43:
 395 005c 83E0      		ldi r24,lo8(3)
 396               	/* #APP */
 397               	 ;  120 "main.c" 1
 398 005e 8093 5700 		sts 87, r24
 399 0062 E895      		spm
 400               		
 401               	 ;  0 "" 2
 114:main.c        **** #if (defined __AVR_ATtiny841__)||(defined __AVR_ATtiny441__)    
 402               		.stabn	68,0,114,.LM44-.LFBB3
 403               	.LM44:
 404               	/* #NOAPP */
 405 0064 3097      		sbiw r30,0
 406 0066 01F4      		brne .L14
 124:main.c        **** }
GAS LISTING /tmp/ccLOy0FK.s 			page 28


 407               		.stabn	68,0,124,.LM45-.LFBB3
 408               	.LM45:
 409 0068 412C      		mov r4,__zero_reg__
 410 006a 512C      		mov r5,__zero_reg__
 411               	.L13:
 412               	.LBE67:
 413               	.LBE66:
 305:main.c        ****         eraseApplication();
 306:main.c        ****       if (command==cmd_write_page) 
 414               		.stabn	68,0,306,.LM46-.LFBB3
 415               	.LM46:
 416 006c 832D      		mov r24,r3
 417 006e 8034      		cpi r24,lo8(64)
 418 0070 01F4      		brne .L15
 419               	.LBB68:
 420               	.LBB69:
 129:main.c        ****       boot_page_write(currentAddress.w - 2);   // will halt CPU, no waiting required
 421               		.stabn	68,0,129,.LM47-.LFBB3
 422               	.LM47:
 423 0072 F201      		movw r30,r4
 424 0074 3297      		sbiw r30,2
 425 0076 E03C      		cpi r30,-64
 426 0078 89E1      		ldi r24,25
 427 007a F807      		cpc r31,r24
 428 007c 00F4      		brsh .L16
 130:main.c        **** }
 429               		.stabn	68,0,130,.LM48-.LFBB3
 430               	.LM48:
 431 007e 85E0      		ldi r24,lo8(5)
 432               	/* #APP */
 433               	 ;  130 "main.c" 1
 434 0080 8093 5700 		sts 87, r24
 435 0084 E895      		spm
 436               		
 437               	 ;  0 "" 2
 438               	/* #NOAPP */
 439 0086 00C0      		rjmp .L16
 440               	.L15:
 441               	.LBE69:
 442               	.LBE68:
 307:main.c        ****         writeFlashPage();          
 308:main.c        ****  #if OSCCAL_SLOW_PROGRAMMING
 309:main.c        ****       OSCCAL      = osccal_tmp;
 310:main.c        ****  #endif
 311:main.c        ****         
 312:main.c        ****       if (command==cmd_exit) {
 443               		.stabn	68,0,312,.LM49-.LFBB3
 444               	.LM49:
 445 0088 8430      		cpi r24,lo8(4)
 446 008a 01F4      		brne .L16
 313:main.c        ****         if (!fastctr) break;  // Only exit after 5 ms timeout     
 447               		.stabn	68,0,313,.LM50-.LFBB3
 448               	.LM50:
 449 008c CD2B      		or r28,r29
 450 008e 01F4      		brne .L18
 451 0090 00C0      		rjmp .L17
 452               	.L16:
GAS LISTING /tmp/ccLOy0FK.s 			page 29


 314:main.c        ****       } else {
 315:main.c        ****         command=cmd_local_nop;     
 453               		.stabn	68,0,315,.LM51-.LFBB3
 454               	.LM51:
 455 0092 312C      		mov r3,__zero_reg__
 456               	.L18:
 457               	.LBB70:
 316:main.c        ****       }  
 317:main.c        ****  
 318:main.c        ****       {
 319:main.c        ****       // This is usbpoll() minus reset logic and double buffering
 320:main.c        ****         int8_t  len;
 321:main.c        ****         len = usbRxLen - 3;
 458               		.stabn	68,0,321,.LM52-.LFBB3
 459               	.LM52:
 460 0094 8091 0000 		lds r24,usbRxLen
 461 0098 8350      		subi r24,lo8(-(-3))
 322:main.c        ****         
 323:main.c        ****         if(len >= 0){
 462               		.stabn	68,0,323,.LM53-.LFBB3
 463               	.LM53:
 464 009a 87FD      		sbrc r24,7
 465 009c 00C0      		rjmp .L19
 466               	.LBB71:
 467               	.LBB72:
 468               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext5
 469               	.Ltext5:
 469:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 470               		.stabn	68,0,469,.LM54-.LFBB3
 471               	.LM54:
 472 009e 9091 0000 		lds r25,usbRxToken
 473 00a2 9D32      		cpi r25,lo8(45)
 474 00a4 01F0      		breq .+2
 475 00a6 00C0      		rjmp .L20
 476               	.LBB73:
 470:usbdrv/usbdrv.c ****             return;
 477               		.stabn	68,0,470,.LM55-.LFBB3
 478               	.LM55:
 479 00a8 8830      		cpi r24,lo8(8)
 480 00aa 01F0      		breq .+2
 481 00ac 00C0      		rjmp .L20
 473:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 482               		.stabn	68,0,473,.LM56-.LFBB3
 483               	.LM56:
 484 00ae 83EC      		ldi r24,lo8(-61)
 485 00b0 8093 0000 		sts usbTxBuf,r24
 474:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 486               		.stabn	68,0,474,.LM57-.LFBB3
 487               	.LM57:
 488 00b4 8AE5      		ldi r24,lo8(90)
 489 00b6 8093 0000 		sts usbTxLen,r24
 478:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 490               		.stabn	68,0,478,.LM58-.LFBB3
 491               	.LM58:
 492 00ba 8091 0000 		lds r24,usbRxBuf+1
 493 00be 8076      		andi r24,lo8(96)
 494 00c0 9091 0000 		lds r25,usbRxBuf+2
GAS LISTING /tmp/ccLOy0FK.s 			page 30


 479:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 495               		.stabn	68,0,479,.LM59-.LFBB3
 496               	.LM59:
 497 00c4 8823      		tst r24
 498 00c6 01F0      		breq .L21
 499               	.LBB74:
 500               	.LBB75:
 501               		.stabs	"main.c",132,0,0,.Ltext6
 502               	.Ltext6:
 169:main.c        ****     usbMsgPtr = (usbMsgPtr_t)configurationReply;
 503               		.stabn	68,0,169,.LM60-.LFBB3
 504               	.LM60:
 505 00c8 9111      		cpse r25,__zero_reg__
 506 00ca 00C0      		rjmp .L22
 170:main.c        ****     return sizeof(configurationReply);      
 507               		.stabn	68,0,170,.LM61-.LFBB3
 508               	.LM61:
 509 00cc 80E0      		ldi r24,lo8(configurationReply)
 510 00ce 90E0      		ldi r25,hi8(configurationReply)
 511 00d0 9093 0000 		sts usbMsgPtr+1,r25
 512 00d4 8093 0000 		sts usbMsgPtr,r24
 171:main.c        ****   } else if (rq->bRequest == cmd_transfer_page) { 
 513               		.stabn	68,0,171,.LM62-.LFBB3
 514               	.LM62:
 515 00d8 86E0      		ldi r24,lo8(6)
 516 00da 00C0      		rjmp .L23
 517               	.L22:
 172:main.c        ****       // Set page address. Address zero always has to be written first to ensure reset vector patch
 518               		.stabn	68,0,172,.LM63-.LFBB3
 519               	.LM63:
 520 00dc 9130      		cpi r25,lo8(1)
 521 00de 01F4      		brne .L24
 175:main.c        ****             currentAddress.b[0]=rq->wIndex.bytes[0] & (~ (SPM_PAGESIZE-1));     
 522               		.stabn	68,0,175,.LM64-.LFBB3
 523               	.LM64:
 524 00e0 4114      		cp r4,__zero_reg__
 525 00e2 5104      		cpc r5,__zero_reg__
 526 00e4 01F0      		breq .L75
 176:main.c        ****             currentAddress.b[1]=rq->wIndex.bytes[1];     
 527               		.stabn	68,0,176,.LM65-.LFBB3
 528               	.LM65:
 529 00e6 8091 0000 		lds r24,usbRxBuf+5
 530 00ea 807C      		andi r24,lo8(-64)
 531 00ec 482E      		mov r4,r24
 177:main.c        ****             
 532               		.stabn	68,0,177,.LM66-.LFBB3
 533               	.LM66:
 534 00ee 5090 0000 		lds r5,usbRxBuf+6
 181:main.c        ****             asm volatile("spm");
 535               		.stabn	68,0,181,.LM67-.LFBB3
 536               	.LM67:
 537 00f2 81E1      		ldi r24,lo8(17)
 538 00f4 87BF      		out 0x37,r24
 182:main.c        ****             
 539               		.stabn	68,0,182,.LM68-.LFBB3
 540               	.LM68:
 541               	/* #APP */
GAS LISTING /tmp/ccLOy0FK.s 			page 31


 542               	 ;  182 "main.c" 1
 543 00f6 E895      		spm
 544               	 ;  0 "" 2
 545               	/* #NOAPP */
 546 00f8 00C0      		rjmp .L75
 547               	.L24:
 185:main.c        ****       writeWordToPageBuffer(rq->wValue.word);
 548               		.stabn	68,0,185,.LM69-.LFBB3
 549               	.LM69:
 550 00fa 9330      		cpi r25,lo8(3)
 551 00fc 01F4      		brne .L26
 186:main.c        ****       writeWordToPageBuffer(rq->wIndex.word);
 552               		.stabn	68,0,186,.LM70-.LFBB3
 553               	.LM70:
 554 00fe 8091 0000 		lds r24,usbRxBuf+3
 555 0102 9091 0000 		lds r25,usbRxBuf+3+1
 556 0106 00D0      		rcall writeWordToPageBuffer
 187:main.c        ****       if ((currentAddress.b[0] % SPM_PAGESIZE) == 0)
 557               		.stabn	68,0,187,.LM71-.LFBB3
 558               	.LM71:
 559 0108 8091 0000 		lds r24,usbRxBuf+5
 560 010c 9091 0000 		lds r25,usbRxBuf+5+1
 561 0110 00D0      		rcall writeWordToPageBuffer
 188:main.c        ****           command=cmd_write_page; // ask runloop to write our page       
 562               		.stabn	68,0,188,.LM72-.LFBB3
 563               	.LM72:
 564 0112 842D      		mov r24,r4
 565 0114 8F73      		andi r24,lo8(63)
 566 0116 01F4      		brne .L75
 189:main.c        ****   } else {
 567               		.stabn	68,0,189,.LM73-.LFBB3
 568               	.LM73:
 569 0118 90E4      		ldi r25,lo8(64)
 570 011a 392E      		mov r3,r25
 571 011c 00C0      		rjmp .L23
 572               	.L26:
 192:main.c        ****   }
 573               		.stabn	68,0,192,.LM74-.LFBB3
 574               	.LM74:
 575 011e 9F73      		andi r25,lo8(63)
 576 0120 392E      		mov r3,r25
 577               	.L75:
 194:main.c        **** }
 578               		.stabn	68,0,194,.LM75-.LFBB3
 579               	.LM75:
 580 0122 80E0      		ldi r24,0
 581 0124 00C0      		rjmp .L23
 582               	.L21:
 583               	.LBE75:
 584               	.LBE74:
 585               	.LBB76:
 586               	.LBB77:
 587               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext7
 588               	.Ltext7:
 395:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 589               		.stabn	68,0,395,.LM76-.LFBB3
 590               	.LM76:
GAS LISTING /tmp/ccLOy0FK.s 			page 32


 591 0126 8091 0000 		lds r24,usbRxBuf+3
 400:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 592               		.stabn	68,0,400,.LM77-.LFBB3
 593               	.LM77:
 594 012a 1092 0000 		sts usbTxBuf+9,__zero_reg__
 595               	.LBB78:
 402:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 596               		.stabn	68,0,402,.LM78-.LFBB3
 597               	.LM78:
 598 012e 9111      		cpse r25,__zero_reg__
 599 0130 00C0      		rjmp .L28
 600               	.LBB79:
 410:usbdrv/usbdrv.c ****         len = 2;
 601               		.stabn	68,0,410,.LM79-.LFBB3
 602               	.LM79:
 603 0132 1092 0000 		sts usbTxBuf+10,__zero_reg__
 604               	.LBE79:
 605               	.LBE78:
 394:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 606               		.stabn	68,0,394,.LM80-.LFBB3
 607               	.LM80:
 608 0136 20E0      		ldi r18,lo8(usbTxBuf+9)
 609 0138 30E0      		ldi r19,hi8(usbTxBuf+9)
 610               	.LBB85:
 611               	.LBB80:
 411:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 612               		.stabn	68,0,411,.LM81-.LFBB3
 613               	.LM81:
 614 013a 82E0      		ldi r24,lo8(2)
 615 013c 00C0      		rjmp .L29
 616               	.L28:
 617               	.LBE80:
 419:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 618               		.stabn	68,0,419,.LM82-.LFBB3
 619               	.LM82:
 620 013e 9530      		cpi r25,lo8(5)
 621 0140 01F4      		brne .L30
 420:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 622               		.stabn	68,0,420,.LM83-.LFBB3
 623               	.LM83:
 624 0142 8093 0000 		sts usbNewDeviceAddr,r24
 625 0146 00C0      		rjmp .L73
 626               	.L30:
 422:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 627               		.stabn	68,0,422,.LM84-.LFBB3
 628               	.LM84:
 629 0148 9630      		cpi r25,lo8(6)
 630 014a 01F4      		brne .L31
 631 014c 9091 0000 		lds r25,usbRxBuf+4
 632               	.LBB81:
 633               	.LBB82:
 634               	.LBB83:
 342:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 635               		.stabn	68,0,342,.LM85-.LFBB3
 636               	.LM85:
 637 0150 9130      		cpi r25,lo8(1)
 638 0152 01F4      		brne .L32
GAS LISTING /tmp/ccLOy0FK.s 			page 33


 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 639               		.stabn	68,0,343,.LM86-.LFBB3
 640               	.LM86:
 641 0154 80E0      		ldi r24,lo8(usbDescriptorDevice)
 642 0156 90E0      		ldi r25,hi8(usbDescriptorDevice)
 643 0158 00C0      		rjmp .L74
 644               	.L32:
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 645               		.stabn	68,0,344,.LM87-.LFBB3
 646               	.LM87:
 647 015a 9230      		cpi r25,lo8(2)
 648 015c 01F4      		brne .L33
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 649               		.stabn	68,0,345,.LM88-.LFBB3
 650               	.LM88:
 651 015e 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 652 0160 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 653               	.L74:
 654 0162 9093 0000 		sts usbMsgPtr+1,r25
 655 0166 8093 0000 		sts usbMsgPtr,r24
 656 016a 82E1      		ldi r24,lo8(18)
 657 016c 00C0      		rjmp .L23
 658               	.L33:
 346:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 659               		.stabn	68,0,346,.LM89-.LFBB3
 660               	.LM89:
 661 016e 9330      		cpi r25,lo8(3)
 662 0170 01F4      		brne .L75
 663               	.LBB84:
 353:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 664               		.stabn	68,0,353,.LM90-.LFBB3
 665               	.LM90:
 666 0172 8111      		cpse r24,__zero_reg__
 667 0174 00C0      		rjmp .L75
 354:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 668               		.stabn	68,0,354,.LM91-.LFBB3
 669               	.LM91:
 670 0176 80E0      		ldi r24,lo8(usbDescriptorString0)
 671 0178 90E0      		ldi r25,hi8(usbDescriptorString0)
 672 017a 9093 0000 		sts usbMsgPtr+1,r25
 673 017e 8093 0000 		sts usbMsgPtr,r24
 674 0182 84E0      		ldi r24,lo8(4)
 675 0184 00C0      		rjmp .L23
 676               	.L31:
 677               	.LBE84:
 678               	.LBE83:
 679               	.LBE82:
 680               	.LBE81:
 425:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 681               		.stabn	68,0,425,.LM92-.LFBB3
 682               	.LM92:
 683 0186 9830      		cpi r25,lo8(8)
 684 0188 01F0      		breq .L47
 428:usbdrv/usbdrv.c ****         usbConfiguration = value;
 685               		.stabn	68,0,428,.LM93-.LFBB3
 686               	.LM93:
 687 018a 9930      		cpi r25,lo8(9)
GAS LISTING /tmp/ccLOy0FK.s 			page 34


 688 018c 01F4      		brne .L34
 429:usbdrv/usbdrv.c ****         usbResetStall();
 689               		.stabn	68,0,429,.LM94-.LFBB3
 690               	.LM94:
 691 018e 8093 0000 		sts usbConfiguration,r24
 692               	.L73:
 693               	.LBE85:
 394:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 694               		.stabn	68,0,394,.LM95-.LFBB3
 695               	.LM95:
 696 0192 20E0      		ldi r18,lo8(usbTxBuf+9)
 697 0194 30E0      		ldi r19,hi8(usbTxBuf+9)
 393:usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 698               		.stabn	68,0,393,.LM96-.LFBB3
 699               	.LM96:
 700 0196 80E0      		ldi r24,0
 701 0198 00C0      		rjmp .L29
 702               	.L34:
 703               	.LBB86:
 431:usbdrv/usbdrv.c ****         len = 1;
 704               		.stabn	68,0,431,.LM97-.LFBB3
 705               	.LM97:
 706 019a 81E0      		ldi r24,lo8(1)
 707 019c 9A30      		cpi r25,lo8(10)
 708 019e 01F0      		breq .L35
 709 01a0 80E0      		ldi r24,0
 710               	.L35:
 711               	.LBE86:
 394:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 712               		.stabn	68,0,394,.LM98-.LFBB3
 713               	.LM98:
 714 01a2 20E0      		ldi r18,lo8(usbTxBuf+9)
 715 01a4 30E0      		ldi r19,hi8(usbTxBuf+9)
 716 01a6 00C0      		rjmp .L29
 717               	.L47:
 718               	.LBB87:
 426:usbdrv/usbdrv.c ****         len = 1;
 719               		.stabn	68,0,426,.LM99-.LFBB3
 720               	.LM99:
 721 01a8 20E0      		ldi r18,lo8(usbConfiguration)
 722 01aa 30E0      		ldi r19,hi8(usbConfiguration)
 427:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 723               		.stabn	68,0,427,.LM100-.LFBB3
 724               	.LM100:
 725 01ac 81E0      		ldi r24,lo8(1)
 726               	.L29:
 727               	.LBE87:
 441:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 728               		.stabn	68,0,441,.LM101-.LFBB3
 729               	.LM101:
 730 01ae 3093 0000 		sts usbMsgPtr+1,r19
 731 01b2 2093 0000 		sts usbMsgPtr,r18
 732               	.L23:
 733               	.LBE77:
 734               	.LBE76:
 498:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 735               		.stabn	68,0,498,.LM102-.LFBB3
GAS LISTING /tmp/ccLOy0FK.s 			page 35


 736               	.LM102:
 737 01b6 9091 0000 		lds r25,usbRxBuf+8
 738 01ba 9111      		cpse r25,__zero_reg__
 739 01bc 00C0      		rjmp .L36
 740 01be 9091 0000 		lds r25,usbRxBuf+7
 741 01c2 9817      		cp r25,r24
 742 01c4 00F4      		brsh .L36
 743 01c6 892F      		mov r24,r25
 744               	.L36:
 504:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 745               		.stabn	68,0,504,.LM103-.LFBB3
 746               	.LM103:
 747 01c8 8093 0000 		sts usbMsgLen,r24
 748               	.L20:
 749               	.LBE73:
 750               	.LBE72:
 751               	.LBE71:
 752               		.stabs	"main.c",132,0,0,.Ltext8
 753               	.Ltext8:
 324:main.c        ****             usbProcessRx(usbRxBuf + 1, len); // only single buffer due to in-order processing
 325:main.c        ****             usbRxLen = 0;       /* mark rx buffer as available */
 754               		.stabn	68,0,325,.LM104-.LFBB3
 755               	.LM104:
 756 01cc 1092 0000 		sts usbRxLen,__zero_reg__
 757               	.L19:
 326:main.c        ****         }
 327:main.c        ****         
 328:main.c        ****         if(usbTxLen & 0x10){    /* transmit system idle */
 758               		.stabn	68,0,328,.LM105-.LFBB3
 759               	.LM105:
 760 01d0 8091 0000 		lds r24,usbTxLen
 761 01d4 84FF      		sbrs r24,4
 762 01d6 00C0      		rjmp .L38
 329:main.c        ****             if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 763               		.stabn	68,0,329,.LM106-.LFBB3
 764               	.LM106:
 765 01d8 8091 0000 		lds r24,usbMsgLen
 766 01dc 8F3F      		cpi r24,lo8(-1)
 767 01de 01F0      		breq .L38
 768 01e0 C82F      		mov r28,r24
 769 01e2 8930      		cpi r24,lo8(9)
 770 01e4 00F0      		brlo .L39
 771 01e6 C8E0      		ldi r28,lo8(8)
 772               	.L39:
 773               	.LBB88:
 774               	.LBB89:
 775               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext9
 776               	.Ltext9:
 570:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 777               		.stabn	68,0,570,.LM107-.LFBB3
 778               	.LM107:
 779 01e8 8C1B      		sub r24,r28
 780 01ea 8093 0000 		sts usbMsgLen,r24
 571:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 781               		.stabn	68,0,571,.LM108-.LFBB3
 782               	.LM108:
 783 01ee 9091 0000 		lds r25,usbTxBuf
GAS LISTING /tmp/ccLOy0FK.s 			page 36


 784 01f2 88E8      		ldi r24,lo8(-120)
 785 01f4 8927      		eor r24,r25
 786 01f6 8093 0000 		sts usbTxBuf,r24
 787               	.LBB90:
 788               	.LBB91:
 526:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 789               		.stabn	68,0,526,.LM109-.LFBB3
 790               	.LM109:
 791 01fa CC23      		tst r28
 792 01fc 01F0      		breq .L40
 793               	.LBB92:
 534:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 794               		.stabn	68,0,534,.LM110-.LFBB3
 795               	.LM110:
 796 01fe 8091 0000 		lds r24,usbMsgPtr
 797 0202 A0E0      		ldi r26,lo8(usbTxBuf+1)
 798 0204 B0E0      		ldi r27,hi8(usbTxBuf+1)
 799 0206 E82F      		mov r30,r24
 800 0208 F091 0000 		lds r31,usbMsgPtr+1
 801               	.L41:
 802               	.LBB93:
 803               	.LBB94:
 539:usbdrv/usbdrv.c ****                     *data++ = c;
 804               		.stabn	68,0,539,.LM111-.LFBB3
 805               	.LM111:
 806               	/* #APP */
 807               	 ;  539 "usbdrv/usbdrv.c" 1
 808 020c 9491      		lpm r25, Z
 809               		
 810               	 ;  0 "" 2
 811               	/* #NOAPP */
 812               	.LBE94:
 540:usbdrv/usbdrv.c ****                     r++;
 813               		.stabn	68,0,540,.LM112-.LFBB3
 814               	.LM112:
 815 020e 9D93      		st X+,r25
 541:usbdrv/usbdrv.c ****                 }while(--i);
 816               		.stabn	68,0,541,.LM113-.LFBB3
 817               	.LM113:
 818 0210 3196      		adiw r30,1
 819 0212 9C2F      		mov r25,r28
 820 0214 980F      		add r25,r24
 821               	.LBE93:
 542:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 822               		.stabn	68,0,542,.LM114-.LFBB3
 823               	.LM114:
 824 0216 9E13      		cpse r25,r30
 825 0218 00C0      		rjmp .L41
 551:usbdrv/usbdrv.c ****         }
 826               		.stabn	68,0,551,.LM115-.LFBB3
 827               	.LM115:
 828 021a F093 0000 		sts usbMsgPtr+1,r31
 829 021e E093 0000 		sts usbMsgPtr,r30
 830               	.L40:
 831               	.LBE92:
 832               	.LBE91:
 833               	.LBE90:
GAS LISTING /tmp/ccLOy0FK.s 			page 37


 574:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 834               		.stabn	68,0,574,.LM116-.LFBB3
 835               	.LM116:
 836 0222 6C2F      		mov r22,r28
 837 0224 80E0      		ldi r24,lo8(usbTxBuf+1)
 838 0226 90E0      		ldi r25,hi8(usbTxBuf+1)
 839 0228 00D0      		rcall usbCrc16Append
 575:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 840               		.stabn	68,0,575,.LM117-.LFBB3
 841               	.LM117:
 842 022a CC5F      		subi r28,lo8(-(4))
 576:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 843               		.stabn	68,0,576,.LM118-.LFBB3
 844               	.LM118:
 845 022c CC30      		cpi r28,lo8(12)
 846 022e 01F0      		breq .L42
 577:usbdrv/usbdrv.c ****     }else{
 847               		.stabn	68,0,577,.LM119-.LFBB3
 848               	.LM119:
 849 0230 8FEF      		ldi r24,lo8(-1)
 850 0232 8093 0000 		sts usbMsgLen,r24
 851               	.L42:
 582:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 852               		.stabn	68,0,582,.LM120-.LFBB3
 853               	.LM120:
 854 0236 C093 0000 		sts usbTxLen,r28
 855               	.L38:
 856               	.LBE89:
 857               	.LBE88:
 858               	.LBE70:
 859               		.stabs	"main.c",132,0,0,.Ltext10
 860               	.Ltext10:
 330:main.c        ****                 usbBuildTxBlock();
 331:main.c        ****             }
 332:main.c        ****         }
 333:main.c        ****       }
 334:main.c        ****       
 335:main.c        ****       idlePolls.w++;
 861               		.stabn	68,0,335,.LM121-.LFBB3
 862               	.LM121:
 863 023a C301      		movw r24,r6
 864 023c 0196      		adiw r24,1
 865 023e 3C01      		movw r6,r24
 336:main.c        **** 
 337:main.c        ****       // Try to execute program when bootloader times out      
 338:main.c        ****       if (AUTO_EXIT_MS&&(idlePolls.w==(AUTO_EXIT_MS/5))) {
 866               		.stabn	68,0,338,.LM122-.LFBB3
 867               	.LM122:
 868 0240 803B      		cpi r24,-80
 869 0242 9440      		sbci r25,4
 870 0244 01F4      		brne .L43
 871               	.LBB95:
 339:main.c        ****          if (pgm_read_byte(BOOTLOADER_ADDRESS - TINYVECTOR_RESET_OFFSET + 1)!=0xff)  break;
 872               		.stabn	68,0,339,.LM123-.LFBB3
 873               	.LM123:
 874 0246 EDEB      		ldi r30,lo8(-67)
 875 0248 F9E1      		ldi r31,lo8(25)
GAS LISTING /tmp/ccLOy0FK.s 			page 38


 876               	/* #APP */
 877               	 ;  339 "main.c" 1
 878 024a E491      		lpm r30, Z
 879               		
 880               	 ;  0 "" 2
 881               	/* #NOAPP */
 882               	.LBE95:
 883 024c EF3F      		cpi r30,lo8(-1)
 884 024e 01F4      		brne .L17
 885               	.L43:
 340:main.c        ****       }
 341:main.c        ****       
 342:main.c        ****       LED_MACRO( idlePolls.b[0] );   
 343:main.c        **** 
 344:main.c        ****        // Test whether another interrupt occurred during the processing of USBpoll and commands.
 345:main.c        ****        // If yes, we missed a data packet on the bus. Wait until the bus was idle for 8.8µs to 
 346:main.c        ****        // allow synchronising to the next incoming packet. 
 347:main.c        ****        
 348:main.c        ****        if (USB_INTR_PENDING & (1<<USB_INTR_PENDING_BIT))  // Usbpoll() collided with data packet
 886               		.stabn	68,0,348,.LM124-.LFBB3
 887               	.LM124:
 888 0250 0AB6      		in __tmp_reg__,0x3a
 889 0252 05FE      		sbrs __tmp_reg__,5
 890 0254 00C0      		rjmp .L44
 891               	.LBB96:
 349:main.c        ****        {        
 350:main.c        ****           uint8_t ctr;
 351:main.c        ****          
 352:main.c        ****           // loop takes 5 cycles
 353:main.c        ****           asm volatile(      
 892               		.stabn	68,0,353,.LM125-.LFBB3
 893               	.LM125:
 894               	/* #APP */
 895               	 ;  353 "main.c" 1
 896 0256 8DE1      		         ldi  r24,29 
 897 0258 B39B      		loop492:  sbis 22,3  
 898 025a 8DE1      		         ldi  r24,29  
 899 025c 8150      		         subi r24,1   
 900 025e 01F4      		         brne loop492 
 901               		
 902               	 ;  0 "" 2
 354:main.c        ****           "         ldi  %0,%1 \n\t"        
 355:main.c        ****           "loop%=:  sbis %2,%3  \n\t"        
 356:main.c        ****           "         ldi  %0,%1  \n\t"
 357:main.c        ****           "         subi %0,1   \n\t"        
 358:main.c        ****           "         brne loop%= \n\t"   
 359:main.c        ****           : "=&d" (ctr)
 360:main.c        ****           :  "M" ((uint8_t)(8.8f*(F_CPU/1.0e6f)/5.0f+0.5)), "I" (_SFR_IO_ADDR(USBIN)), "M" (USB_CFG
 361:main.c        ****           );       
 362:main.c        ****          USB_INTR_PENDING = 1<<USB_INTR_PENDING_BIT;                   
 903               		.stabn	68,0,362,.LM126-.LFBB3
 904               	.LM126:
 905               	/* #NOAPP */
 906 0260 80E2      		ldi r24,lo8(32)
 907 0262 8ABF      		out 0x3a,r24
 908 0264 00C0      		rjmp .L44
 909               	.L17:
GAS LISTING /tmp/ccLOy0FK.s 			page 39


 910               	.LBE96:
 911               	.LBE65:
 363:main.c        ****        }                        
 364:main.c        ****     } while(1);  
 365:main.c        **** 
 366:main.c        ****     LED_EXIT();
 367:main.c        ****     
 368:main.c        ****     initHardware();  /* Disconnect micronucleus */    
 912               		.stabn	68,0,368,.LM127-.LFBB3
 913               	.LM127:
 914 0266 00D0      		rcall initHardware
 369:main.c        ****     
 370:main.c        ****     USB_INTR_ENABLE = 0;
 915               		.stabn	68,0,370,.LM128-.LFBB3
 916               	.LM128:
 917 0268 1BBE      		out 0x3b,__zero_reg__
 371:main.c        ****     USB_INTR_CFG = 0;       /* also reset config bits */
 918               		.stabn	68,0,371,.LM129-.LFBB3
 919               	.LM129:
 920 026a 15BA      		out 0x15,__zero_reg__
 921               	.LBB97:
 922               	.LBB98:
 231:main.c        ****   
 923               		.stabn	68,0,231,.LM130-.LFBB3
 924               	.LM130:
 925               	/* #APP */
 926               	 ;  231 "main.c" 1
 927 026c 00C0      		rjmp __vectors - 4
 928               	 ;  0 "" 2
 929               	/* #NOAPP */
 930               	.L46:
 931 026e 00C0      		rjmp .L46
 932               	.LBE98:
 933               	.LBE97:
 934               		.size	main, .-main
 935               		.stabs	"fastctr:r(5,4)",64,0,274,28
 936               		.stabs	"resetctr:r(5,2)",64,0,275,17
 937               		.stabn	192,0,0,.LBB65-.LFBB3
 938               		.stabs	"ptr:r(5,4)",64,0,112,30
 939               		.stabn	192,0,0,.LBB67-.LFBB3
 940               		.stabn	224,0,0,.LBE67-.LFBB3
 941               		.stabs	"dataPtr:r(0,52)=*(0,11)",64,0,394,18
 942               		.stabs	"value:r(0,11)",64,0,395,24
 943               		.stabn	192,0,0,.LBB77-.LFBB3
 944               		.stabs	"_cmd:r(0,11)",64,0,341,25
 945               		.stabn	192,0,0,.LBB83-.LFBB3
 946               		.stabn	224,0,0,.LBE83-.LFBB3
 947               		.stabn	224,0,0,.LBE77-.LFBB3
 948               		.stabs	"len:r(0,11)",64,0,565,28
 949               		.stabn	192,0,0,.LBB89-.LFBB3
 950               		.stabs	"len:r(0,11)",64,0,237,28
 951               		.stabn	192,0,0,.LBB90-.LFBB3
 952               		.stabn	224,0,0,.LBE90-.LFBB3
 953               		.stabn	224,0,0,.LBE89-.LFBB3
 954               		.stabn	224,0,0,.LBE65-.LFBB3
 955               	.Lscope3:
 956               		.stabs	"",36,0,0,.Lscope3-.LFBB3
GAS LISTING /tmp/ccLOy0FK.s 			page 40


 957               		.stabd	78,0,0
 958               	.global	configurationReply
 959               		.section	.progmem.data.configurationReply,"a",@progbits
 960               		.type	configurationReply, @object
 961               		.size	configurationReply, 6
 962               	configurationReply:
 963 0000 19        		.byte	25
 964 0001 BA        		.byte	-70
 965 0002 40        		.byte	64
 966 0003 05        		.byte	5
 967 0004 93        		.byte	-109
 968 0005 0B        		.byte	11
 969               	.global	usbDescriptorConfiguration
 970               		.section	.progmem.data.usbDescriptorConfiguration,"a",@progbits
 971               		.type	usbDescriptorConfiguration, @object
 972               		.size	usbDescriptorConfiguration, 18
 973               	usbDescriptorConfiguration:
 974 0000 09        		.byte	9
 975 0001 02        		.byte	2
 976 0002 12        		.byte	18
 977 0003 00        		.byte	0
 978 0004 01        		.byte	1
 979 0005 01        		.byte	1
 980 0006 00        		.byte	0
 981 0007 80        		.byte	-128
 982 0008 32        		.byte	50
 983 0009 09        		.byte	9
 984 000a 04        		.byte	4
 985 000b 00        		.byte	0
 986 000c 00        		.byte	0
 987 000d 00        		.byte	0
 988 000e 00        		.byte	0
 989 000f 00        		.byte	0
 990 0010 00        		.byte	0
 991 0011 00        		.byte	0
 992               	.global	usbDescriptorDevice
 993               		.section	.progmem.data.usbDescriptorDevice,"a",@progbits
 994               		.type	usbDescriptorDevice, @object
 995               		.size	usbDescriptorDevice, 18
 996               	usbDescriptorDevice:
 997 0000 12        		.byte	18
 998 0001 01        		.byte	1
 999 0002 10        		.byte	16
 1000 0003 01        		.byte	1
 1001 0004 FF        		.byte	-1
 1002 0005 00        		.byte	0
 1003 0006 00        		.byte	0
 1004 0007 08        		.byte	8
 1005 0008 D0        		.byte	-48
 1006 0009 16        		.byte	22
 1007 000a 53        		.byte	83
 1008 000b 07        		.byte	7
 1009 000c 03        		.byte	3
 1010 000d 02        		.byte	2
 1011 000e 00        		.byte	0
 1012 000f 00        		.byte	0
 1013 0010 00        		.byte	0
GAS LISTING /tmp/ccLOy0FK.s 			page 41


 1014 0011 01        		.byte	1
 1015               	.global	usbDescriptorString0
 1016               		.section	.progmem.data.usbDescriptorString0,"a",@progbits
 1017               		.type	usbDescriptorString0, @object
 1018               		.size	usbDescriptorString0, 4
 1019               	usbDescriptorString0:
 1020 0000 04        		.byte	4
 1021 0001 03        		.byte	3
 1022 0002 09        		.byte	9
 1023 0003 04        		.byte	4
 1024               		.section	.bss.usbMsgLen,"aw",@nobits
 1025               		.type	usbMsgLen, @object
 1026               		.size	usbMsgLen, 1
 1027               	usbMsgLen:
 1028 0000 00        		.zero	1
 1029               		.comm	usbMsgPtr,2,1
 1030               		.comm	usbTxBuf,11,1
 1031               		.comm	usbTxLen,1,1
 1032               		.comm	usbRxToken,1,1
 1033               		.comm	usbCurrentTok,1,1
 1034               		.comm	usbRxLen,1,1
 1035               		.comm	usbConfiguration,1,1
 1036               		.comm	usbNewDeviceAddr,1,1
 1037               		.comm	usbDeviceAddr,1,1
 1038               		.comm	usbInputBufOffset,1,1
 1039               		.comm	usbRxBuf,22,1
 1040               		.stabs	"usbMsgLen:S(0,11)",40,0,67,usbMsgLen
 1041               		.stabs	"usbMsgPtr:G(0,52)",32,0,65,0
 1042               		.stabs	"usbRxToken:G(0,11)",32,0,44,0
 1043               		.stabs	"usbConfiguration:G(0,11)",32,0,41,0
 1044               		.stabs	"usbDescriptorDevice:G(0,53)=ar(13,4);0;17;(0,54)=k(0,2)",32,0,135,0
 1045               		.stabs	"usbDescriptorConfiguration:G(0,53)",32,0,166,0
 1046               		.stabs	"usbDescriptorString0:G(0,55)=ar(13,4);0;3;(0,54)",32,0,94,0
 1047               		.stabs	"usbRxBuf:G(0,56)=ar(13,4);0;21;(0,11)",32,0,37,0
 1048               		.stabs	"usbInputBufOffset:G(0,11)",32,0,38,0
 1049               		.stabs	"usbDeviceAddr:G(0,11)",32,0,39,0
 1050               		.stabs	"usbNewDeviceAddr:G(0,11)",32,0,40,0
 1051               		.stabs	"usbRxLen:G(0,57)=B(0,10)",32,0,42,0
 1052               		.stabs	"usbCurrentTok:G(0,11)",32,0,43,0
 1053               		.stabs	"usbTxLen:G(13,2)",32,0,46,0
 1054               		.stabs	"usbTxBuf:G(13,3)",32,0,50,0
 1055               		.stabs	"configurationReply:G(0,58)=ar(13,4);0;5;(0,59)=k(5,2)",32,0,56,0
 1056               		.stabs	"currentAddress:r(0,48)",64,0,74,4
 1057               		.stabs	"idlePolls:r(0,48)",64,0,75,6
 1058               		.stabs	"command:r(5,2)",64,0,87,3
 1059               		.text
 1060               		.stabs	"",100,0,0,.Letext0
 1061               	.Letext0:
 1062               		.ident	"GCC: (GNU) 4.9.2"
 1063               	.global __do_clear_bss
GAS LISTING /tmp/ccLOy0FK.s 			page 42


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccLOy0FK.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccLOy0FK.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccLOy0FK.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccLOy0FK.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccLOy0FK.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccLOy0FK.s:131    .text.writeWordToPageBuffer:0000000000000000 writeWordToPageBuffer
     /tmp/ccLOy0FK.s:188    .text.initHardware:0000000000000000 initHardware
                            *COM*:0000000000000001 usbTxLen
     /tmp/ccLOy0FK.s:1027   .bss.usbMsgLen:0000000000000000 usbMsgLen
     /tmp/ccLOy0FK.s:264    .text.startup.main:0000000000000000 main
                            *COM*:0000000000000001 usbNewDeviceAddr
                            *COM*:0000000000000001 usbDeviceAddr
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbRxToken
                            *COM*:000000000000000b usbTxBuf
                            *COM*:0000000000000016 usbRxBuf
     /tmp/ccLOy0FK.s:962    .progmem.data.configurationReply:0000000000000000 configurationReply
                            *COM*:0000000000000002 usbMsgPtr
     /tmp/ccLOy0FK.s:996    .progmem.data.usbDescriptorDevice:0000000000000000 usbDescriptorDevice
     /tmp/ccLOy0FK.s:973    .progmem.data.usbDescriptorConfiguration:0000000000000000 usbDescriptorConfiguration
     /tmp/ccLOy0FK.s:1019   .progmem.data.usbDescriptorString0:0000000000000000 usbDescriptorString0
                            *COM*:0000000000000001 usbConfiguration
     /tmp/ccLOy0FK.s:897    .text.startup.main:0000000000000258 loop492
                            *COM*:0000000000000001 usbCurrentTok
                            *COM*:0000000000000001 usbInputBufOffset

UNDEFINED SYMBOLS
calibrateOscillatorASM
__vector_2
usbCrc16Append
__vectors
__do_clear_bss
